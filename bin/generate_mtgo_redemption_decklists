#!/usr/bin/env ruby

require_relative "../search-engine/lib/card_database"
require "csv"
require "pry"

DECKS_ROOT = Pathname("#{ENV['HOME']}/github/magic-preconstructed-decks")
DB = CardDatabase.load

# Many of the dates are likely bad, but it's not a huge deal
KNOWN_NOT_REDEEMABLE = [
  "fdn", # https://www.mtgo.com/news/foundations-on-mtgo
  "fin", # https://www.mtgo.com/news/final-fantasy-on-mtgo
  "big", # https://old.reddit.com/r/MTGO/comments/1c0oaty/will_the_big_score_be_redeemable/ (reddit comment by Daybreak Games employee Squiddy683)
  "mat", # https://old.reddit.com/r/magicTCG/comments/19cawcd/march_of_the_machine_and_mom_aftermath/ (just random redditors commenting)
  "spm", # not on MTGO
  "w16", # it's Standard-legal supplemental product, this kind of product is not typically redeemable
  "w17", # it's Standard-legal supplemental product, this kind of product is not typically redeemable
  "g18", # it's Standard-legal supplemental product, this kind of product is not typically redeemable
]
# For tsb, found boxes on sale https://spankyscardshop.com/products/tsp-time-spiral-time-shifted-mol-regular-complete-set-factory-sealed-mtg-magic-the-gathering

class GenerateSetRedemptionDecklists
  # : is not a legal character on Windows, so do this for compatibility
  def set_name_path
    set.name.gsub(":", "-")
  end

  def regular_path
    DECKS_ROOT + "data/redemption/#{set.code}/#{set_name_path} Redemption.txt"
  end

  def foil_path
    DECKS_ROOT + "data/redemption/#{set.code}/#{set_name_path} Foil Redemption.txt"
  end

  def initialize(source: nil, numbers: nil, date: nil, set_code:, query: nil, card_count: nil)
    @set_code = set_code
    @source = source
    @numbers = numbers
    @numbers = 1..set.base_set_size if @numbers.nil?
    @date = date || set.release_date + 30
    @query = query
    @card_count = card_count || @numbers.size
  end

  def set
    @set ||= DB.sets[@set_code] or raise "Unknown set #{@set_code}"
  end

  def regular_query
    DB.search("e:#{@set_code} is:baseset game:mtgo #{@query} is:nonfoil").printings
  end

  def foil_query
    DB.search("e:#{@set_code} is:baseset game:mtgo #{@query} is:nonfoil").printings
  end

  def regular_number_range
    set.printings.select{
      @numbers.include?(_1.number.to_i) and _1.mtgo? and _1.foiling != :foilonly and !_1.variant_foreign and !_1.variant_misprint
    }
  end

  def foil_number_range
    set.printings.select{
      @numbers.include?(_1.number.to_i) and _1.mtgo? and _1.foiling != :nonfoil and !_1.variant_foreign and !_1.variant_misprint
    }
  end

  def regular_cards
    @regular_cards ||= if @query
      regular_query.map{ PhysicalCard.for(_1) }.uniq
    else
      regular_number_range.map{ PhysicalCard.for(_1) }.uniq
    end
  end

  def foil_cards
    @foil_cards ||= if @query
      foil_query.map{ PhysicalCard.for(_1) }.uniq
    else
      foil_number_range.map{ PhysicalCard.for(_1) }.uniq
    end
  end

  def regular_name
    "#{set.name} Redemption"
  end

  def foil_name
    "#{set.name} Foil Redemption"
  end

  def generate_regular
    if @numbers
      warn "#{@set_code} Wrong number of regular cards, expected #{@card_count} (#{@numbers}), got #{regular_cards.size}" if regular_cards.size != @card_count
    end

    regular_path.parent.mkpath
    regular_path.open("w") do |fh|
      fh.puts "// NAME: #{regular_name}"
      fh.puts "// SOURCE: #{@source}" if @source
      fh.puts "// DATE: #{@date}"
      regular_cards.each do |card|
        fh.puts "1 #{card.name} [#{set.code.upcase}:#{card.number}]"
      end
    end
  end

  def generate_foil
    if @numbers
      warn "#{@set_code} Wrong number of foil cards, expected #{@card_count} (#{@numbers}), got #{foil_cards.size}" if foil_cards.size != @card_count
    end

    foil_path.open("w") do |fh|
      fh.puts "// NAME: #{foil_name}"
      fh.puts "// SOURCE: #{@source}" if @source
      fh.puts "// DATE: #{@date}"
      foil_cards.each do |card|
        fh.puts "1 #{card.name} [#{set.code.upcase}:#{card.number}] [foil]"
      end
    end
  end

  def call
    generate_regular
    # The End of Foil Redemption Sets, starting with Bloomburrow
    # https://www.mtgo.com/news/mtgo-eofr-0302024
    if @date < Date.parse("2024-08-02")
      generate_foil
    end
  end
end

class GenerateMtgoRedemptionDecklists
  def set_data_path
    Pathname(__dir__) + "../data/mtgo_redemption.csv"
  end

  def set_data
    @set_data ||= CSV.read(
      set_data_path,
      headers: true,
      header_converters: :symbol,
      converters: [:integer, :date]
    )
  end

  def warn_about_missing_redemptions
    redeemable = set_data.map{|row| row[:code].downcase }
    std_sets = DB.sets.values.select{|set| set.release_date >= Date.parse("2000-10-02") and set.types.include?("standard") }.map(&:code)
    should_be_redeemable = std_sets - redeemable - KNOWN_NOT_REDEEMABLE
    unless should_be_redeemable.empty?
      warn "These sets should probably be redemable on MTGO: #{should_be_redeemable.join(" ")}"
    end
  end

  def call
    # Name column is just for our convenient, we always use set name from db
    set_data.each do |row|
      source = row[:query] ? "database query with #{row[:query]}" : "default database query"
      source += "; #{row[:source]}" if row[:source]
      GenerateSetRedemptionDecklists.new(
        date: row[:date],
        set_code: row[:code].downcase,
        query: row[:query],
        card_count: row[:card_count],
        source: source
      ).call
    end

    warn_about_missing_redemptions
  end
end

GenerateMtgoRedemptionDecklists.new.call
